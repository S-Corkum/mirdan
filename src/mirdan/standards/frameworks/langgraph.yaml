principles:
  - Define state as TypedDict with Annotated reducers (e.g., Annotated[list, add_messages]) - keep state minimal, typed, and explicit
  - Treat nodes as pure functions that return partial state updates - never mutate the state object directly
  - Use add_messages reducer for message list accumulation - never replace the message list entirely
  - Use simple edges (add_edge) for linear flows - reserve add_conditional_edges for genuine decision points
  - Always call .compile() on StateGraph before invocation - StateGraph is a builder, not an executable graph
  - Use PostgresSaver or SqliteSaver for production checkpointing - MemorySaver is in-memory only for development
  - Implement bounded loops with max_steps counters and explicit exit conditions to prevent runaway execution
  - Use interrupt() within nodes for human-in-the-loop at sensitive decision points with context about the proposed action
  - Use configurable parameter for thread_id and runtime settings - never hardcode thread identifiers or model providers

forbidden:
  - Using MemorySaver in production code (in-memory only, state lost on restart)
  - Mutating state objects directly in nodes instead of returning partial state updates
  - Creating unbounded agentic loops without max_steps counter or explicit exit conditions
  - Using deprecated langgraph.prebuilt module (moved to langchain.agents in 1.0)
  - Storing transient computation values in graph state - use function-local scope for intermediate results
  - Invoking StateGraph directly without calling .compile() - only compiled graphs support invoke/stream
  - Using add_conditional_edges with routing function return strings that do not match the mapping dictionary keys

patterns:
  state_definition: "TypedDict with Annotated[list, add_messages] for messages; keep other fields minimal with Optional types"
  graph_construction: "StateGraph(State) -> add_node('name', fn) -> add_edge/add_conditional_edges -> .compile(checkpointer=saver)"
  conditional_routing: "def route(state: State) -> str: return 'next_node_name' based on state examination"
  checkpointing: "PostgresSaver(conn_string) with thread_id in config for durable, thread-scoped execution persistence"
  human_in_loop: "interrupt({'action': proposed, 'risk': level}) within node; resume with Command(resume={'approved': True})"
